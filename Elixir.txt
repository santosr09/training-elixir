Elixir

Installing Elixier
1_Add Repository:
wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb && sudo dpkg -i erlang-solutions_2.0_all.deb
2_Update:
sudo apt-get update
3_Install the Erlang/OTP platform and all of its applications: 
sudo apt-get install esl-erlang
4_It is highly recommended to add Elixirâ€™s bin path to your PATH environment variable to ease development:


export PATH="$PATH:/usr/bin/elixir"

STRINGS:
   Interpolacion:
   handle = "taylor"
   "My Twitter is @#{handle}"

   one = 1
   "Test: #{one}"

TUPLES
   IS A ORDERED COLECTION

   book = {"Programming Elixir", "Dave Thomas", 25.00}

   Retrieving data from a Tuple:
   elem(book, 2)
   >25.0

   Adding to a Tuple:
   put_elem(book, 2, 48.00)

IN ELIXIR DATA IS INMUTABLE

PATTERN MATCHING

_Dos tipos de archivo ex (compilado, se carga a disco) y exs (scripts)

_Ejecutar/Cargas un modulo en exs:
iex "name_of_file.exs"

_Reload a file(module); This will give us a warning that we are redifining a module; inside iex type:
>r(ModuleName)

_Execute a function; Inside iex type:
>ModuleName.function_name


_Import a module (import itself is a function):
import NAME_MODULE
import IO

_Best practices when importing Module is to limit the functions we are going to use:
import MODULE_NAME, <OPTION:> [<FUNCTION_NAME>, <#>]
import IO, only: [puts: 1] 

_Kernel is imported into every module (CompileError:imported Kernel.inspect/1 conflicts with local function), we have a function with the same name that a function already imported in module Kernel

_We can import a module, EXCEPT some fucntions:
import Kernel, except: [inspect: 1]


_IMPORT A FILE:
>import_file("name_file.exs")

_CREATE AN ALIAS FOR A MODULE:
alias NAME.OF.THE.MODULE.NAME

NAME.function_used
_This create an alias withouth especifying a custom alias

_ESPECIFYING A CUSTOM ALIAS:
alias NAME.OF.THE.MODULE.NAME, as: MyCustomAlias

_DIRECTIVE 'required': USED TO BRING A MACRO
Example of error at compile time:
"warning: you must require Integer before invoking the macro Integer.is_even/1"
_SOLUTION: add the reuire directive:
require Integer

_DIRECTIVES(import, alias, require) can be Module scope or Function Scope


_DEFINE A MODULE:
defmodule Sample.Enum do
    #Your tasks here!
end

_In functions Elixir return the last evaluated expresion:

_FUNCTION ARITY: Number of parameters

_Defining a function
def first(list) do
   hd(list)
end

_ARITY
first/1
{function name} / {number of parameters}

_Example of pattern matching

def some_func(quantity, {_, _, price}) do
   quantity * price
end

def some_func(quantity, book) do
   quantity * elem(book, 2)
end

_Both Functions perform the same operations, but first one is more legible.

_GUARD CLAUSES
_It's a kind of precondition validation for method invocation

defmodule Sample.Calendar do
   def is_leap_year(year) when rem(year, 400) == 0, do: true
   def is leap_year(year) when rem(year, 100) == 0, do: true
   def is_leap_year(year) when rem(year, 4) == 0, do:true
   def is_leap_year(year), do: false

end

_ERROR:
iex(8)> r(Sample.Calendar)     
** (ArgumentError) could not load nor find module: Sample.Calendar
_SOLUTION:
_CARGAR EL ARCHIVO EN IEX:
iex ("file_name.exs")

_Errores de Sintaxys evitan que se cargue el archivo
** (SyntaxError) calendar.exs:5: keyword argument must be followed by space after: do:


_DEFAULT_PARAMETERS
_We can specify default values for parameters, if user don't provide a value for that parameter, default value will be used

_SYNTAX: We use '\\' near to the variable name, to define a default value
_EXAMPLE:

def add(list, val \\ 0) do
   [val | list]
end

_Multiple clauses with deafult values should define a function head with the deafult values:

def first(list, val \\ nil)  #This is the head function defining the default value for first/2 function

def first([head | _], _), do: head
def first([], val), do: val

_PRIVATE_FUNCTIONS
_SYNTAX: We use 'defp' to define a private function

_FUNCTIONS AS FIRST CLASS CITIZENS
Supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables

#We pass the square function to map function
Enum.map(list, &Sample.Utils.square/1)


_The amperson operator '&' is the capture operator, is a reference to the function, we especify the Arity of the function, this tells Elixir wich version of the function to use.

_ANONYMOUS FUNCTION

_Syntax:
#Everything between > and end is the value's function
fn(x) -> x*x end

_Example:
Enum.map(list, fn(x) -> x*x end)

#Tha anonymous function can take multiple parameters:
fn(x, acc) -> acc + x end

_Example:
Enum.reduce(list, 0, fn(x, acc) -> acc + x end)


_Syntax usgin the capture syntax:
#&1 refers to first parameter
Enum.map(list, &(&1 * &1))

#&1 refers to first parameter, &2 refers to second parameter
Enum.reduce(list, 0, &(&1 + &2))

_To compile in Elixir
c("name_of_file.exs")

Sample.Utils.custom_func(1, fn(x) -> IO.puts(x) end)1

=========================================================
=========================================================


